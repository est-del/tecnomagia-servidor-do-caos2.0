<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Servidor do Caos - Tecnomagia Quântica Avançada</title>
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Cpolygon points='50,10 90,30 90,70 50,90 10,70 10,30' fill='%2300ffff' opacity='0.7'/%3E%3C/svg%3E" type="image/svg+xml">
  <style>
    :root {
      --neon-cyan: #0ff;
      --neon-magenta: #f0f;
      --neon-yellow: #ff0;
      --neon-green: #0f0;
      --neon-red: #f00;
      --dark-bg: #000;
      --panel-bg: rgba(0, 20, 30, 0.8);
      --quantum-gradient: linear-gradient(45deg, #0ff, #f0f, #ff0, #0f0);
    }
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    body {
      background: var(--dark-bg) radial-gradient(circle at 50% 50%, rgba(0, 255, 255, 0.1) 0%, transparent 70%);
      color: var(--neon-cyan);
      font-family: 'Courier New', monospace;
      overflow-x: hidden;
      min-height: 100vh;
      position: relative;
    }
    .quantum-background {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -1;
      background: 
        radial-gradient(circle at 20% 20%, rgba(0, 255, 255, 0.1) 0%, transparent 50%),
        radial-gradient(circle at 80% 80%, rgba(255, 0, 255, 0.1) 0%, transparent 50%),
        radial-gradient(circle at 40% 70%, rgba(255, 255, 0, 0.1) 0%, transparent 50%);
      animation: quantum-shift 20s infinite ease-in-out;
    }
    @keyframes quantum-shift {
      0%, 100% { transform: scale(1) rotate(0deg); }
      33% { transform: scale(1.1) rotate(120deg); }
      66% { transform: scale(0.9) rotate(240deg); }
    }
    .main-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
      position: relative;
      z-index: 1;
    }
    .ritual-panel {
      border: 2px solid var(--neon-cyan);
      box-shadow: 
        0 0 40px rgba(0, 255, 255, 0.4),
        inset 0 0 40px rgba(0, 255, 255, 0.1);
      padding: 2rem;
      margin: 2rem auto;
      max-width: 1000px;
      text-align: center;
      backdrop-filter: blur(15px);
      background: var(--panel-bg);
      position: relative;
      border-radius: 15px;
      animation: panel-pulse 4s infinite alternate;
    }
    @keyframes panel-pulse {
      from { 
        box-shadow: 0 0 20px rgba(0, 255, 255, 0.4), inset 0 0 20px rgba(0, 255, 255, 0.1);
        border-color: var(--neon-cyan);
      }
      to { 
        box-shadow: 0 0 60px rgba(0, 255, 255, 0.8), inset 0 0 60px rgba(0, 255, 255, 0.2);
        border-color: var(--neon-magenta);
      }
    }
    .title {
      font-size: 2.5rem;
      background: var(--quantum-gradient);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      animation: title-glow 3s infinite alternate;
      margin-bottom: 1rem;
      text-shadow: 0 0 20px var(--neon-cyan);
    }
    @keyframes title-glow {
      from { filter: drop-shadow(0 0 10px var(--neon-cyan)); }
      to { filter: drop-shadow(0 0 30px var(--neon-magenta)); }
    }
    .subtitle {
      color: var(--neon-yellow);
      font-style: italic;
      margin-bottom: 2rem;
      text-shadow: 0 0 10px var(--neon-yellow);
      font-size: 1.2rem;
    }
    .form-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 1.5rem;
      margin-bottom: 2rem;
    }
    .input-group {
      display: flex;
      flex-direction: column;
      margin-bottom: 1rem;
    }
    .input-group label {
      margin-bottom: 0.5rem;
      color: var(--neon-green);
      font-weight: bold;
      text-align: left;
    }
    input, textarea, select {
      width: 100%;
      padding: 12px;
      margin: 5px 0;
      border-radius: 8px;
      background: rgba(0, 30, 40, 0.9);
      border: 2px solid var(--neon-cyan);
      color: var(--neon-cyan);
      font-family: inherit;
      font-size: 14px;
      transition: all 0.3s;
    }
    input:focus, textarea:focus, select:focus {
      outline: none;
      border-color: var(--neon-magenta);
      box-shadow: 0 0 20px rgba(255, 0, 255, 0.5);
    }
    input::placeholder, textarea::placeholder {
      color: rgba(0, 255, 255, 0.5);
    }
    textarea {
      min-height: 80px;
      resize: vertical;
    }
    .button {
      background: transparent;
      border: 2px solid var(--neon-cyan);
      color: var(--neon-cyan);
      padding: 12px 30px;
      font-size: 1.1rem;
      cursor: pointer;
      transition: all 0.3s;
      margin: 0.5rem;
      font-weight: bold;
      position: relative;
      overflow: hidden;
      border-radius: 8px;
      font-family: inherit;
    }
    .button:hover {
      box-shadow: 0 0 30px currentColor;
      transform: scale(1.05);
    }
    .button::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(0, 255, 255, 0.4), transparent);
      transition: 0.5s;
    }
    .button:hover::before {
      left: 100%;
    }
    .button.primary {
      border-color: var(--neon-magenta);
      color: var(--neon-magenta);
      font-size: 1.3rem;
      padding: 15px 40px;
    }
    .button.gnostic {
      border-color: var(--neon-green);
      color: var(--neon-green);
      background: rgba(0, 255, 0, 0.1);
    }
    .button.collapse {
      border-color: var(--neon-yellow);
      color: var(--neon-yellow);
      background: rgba(255, 255, 0, 0.1);
      font-size: 1.2rem;
      padding: 20px 40px;
      margin: 20px auto;
      display: block;
    }
    .quantum-display {
      border: 1px dashed var(--neon-cyan);
      background: rgba(0, 0, 0, 0.8);
      padding: 20px;
      border-radius: 10px;
      margin: 20px 0;
      min-height: 200px;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      overflow: hidden;
      transition: all 0.5s ease;
    }
    .quantum-grid {
      display: grid;
      grid-template-columns: repeat(9, 1fr);
      gap: 8px;
      margin: 2rem auto;
      width: 300px;
      padding: 20px;
      background: rgba(0, 255, 255, 0.1);
      border-radius: 10px;
    }
    .qubit {
      height: 25px;
      width: 25px;
      background: #333;
      border-radius: 50%;
      transition: all 0.5s ease;
      position: relative;
    }
    .qubit.active {
      background: var(--neon-yellow);
      box-shadow: 0 0 20px var(--neon-yellow);
      animation: qubit-pulse 1s infinite alternate;
    }
    @keyframes qubit-pulse {
      from { transform: scale(1); }
      to { transform: scale(1.2); }
    }
    .visualization-container {
      position: relative;
      width: 400px;
      height: 400px;
      margin: 20px auto;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 50%;
      border: 1px solid var(--neon-cyan);
      overflow: hidden;
    }
    .merkaba-container {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 200px;
      height: 200px;
    }
    .merkaba-rotation {
      width: 100%;
      height: 100%;
      animation: merkaba-spin 8s linear infinite;
    }
    @keyframes merkaba-spin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }
    .sigil-container {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 15;
      width: 180px;
      height: 180px;
      border-radius: 50%;
      overflow: hidden;
      border: 3px solid var(--neon-yellow);
      box-shadow: 0 0 30px var(--neon-yellow);
      display: none;
      animation: sigil-pulse 3s infinite ease-in-out;
    }
    @keyframes sigil-pulse {
      0%, 100% { transform: translate(-50%, -50%) scale(1); opacity: 0.7; }
      50% { transform: translate(-50%, -50%) scale(1.1); opacity: 1; }
    }
    .sigil-image {
      width: 100%;
      height: 100%;
      object-fit: contain;
    }
    .witness-container {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 10;
      width: 120px;
      height: 120px;
      border-radius: 50%;
      overflow: hidden;
      border: 3px solid var(--neon-cyan);
      box-shadow: 0 0 30px var(--neon-cyan);
      display: none;
    }
    .witness-image {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    .radiographic-container {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 5;
      width: 140px;
      height: 140px;
      border-radius: 50%;
      overflow: hidden;
      border: 2px solid var(--neon-magenta);
      box-shadow: 0 0 20px var(--neon-magenta);
      animation: radiographic-spin 12s linear infinite;
      display: none;
    }
    @keyframes radiographic-spin {
      from { transform: translate(-50%, -50%) rotate(0deg); }
      to { transform: translate(-50%, -50%) rotate(360deg); }
    }
    .radiographic-image {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    .pantacle-container {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 20;
      width: 300px;
      height: 300px;
      opacity: 0.7;
      pointer-events: none;
      display: none;
    }
    .pantacle-image {
      width: 100%;
      height: 100%;
      object-fit: contain;
    }
    .frequency-display {
      background: rgba(0, 255, 255, 0.1);
      border: 1px solid var(--neon-cyan);
      padding: 15px;
      border-radius: 8px;
      margin: 15px 0;
    }
    .status-panel {
      position: fixed;
      bottom: 20px;
      left: 20px;
      background: var(--panel-bg);
      border: 1px solid var(--neon-green);
      padding: 15px;
      border-radius: 8px;
      max-width: 300px;
      z-index: 1000;
    }
    .config-panel {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: var(--panel-bg);
      border: 1px solid var(--neon-yellow);
      padding: 15px;
      border-radius: 8px;
      z-index: 1000;
    }
    .config-toggle {
      cursor: pointer;
      color: var(--neon-yellow);
      text-decoration: underline;
      margin-bottom: 10px;
    }
    #config-form {
      display: none;
    }
    .lunar-phase {
      display: inline-block;
      width: 30px;
      height: 30px;
      border-radius: 50%;
      background: var(--neon-yellow);
      position: relative;
      margin: 0 10px;
      box-shadow: 0 0 15px var(--neon-yellow);
    }
    .solfeggio-frequencies {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
      gap: 10px;
      margin: 15px 0;
    }
    .freq-button {
      padding: 8px 12px;
      border: 1px solid var(--neon-cyan);
      background: transparent;
      color: var(--neon-cyan);
      cursor: pointer;
      border-radius: 5px;
      font-size: 12px;
      transition: all 0.3s;
    }
    .freq-button:hover, .freq-button.active {
      background: var(--neon-cyan);
      color: var(--dark-bg);
      box-shadow: 0 0 15px var(--neon-cyan);
    }
    .sacred-geometry {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      opacity: 0.3;
    }
    .energy-field {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 300px;
      height: 300px;
      border: 1px solid var(--neon-magenta);
      border-radius: 50%;
      animation: energy-pulse 3s infinite ease-in-out;
    }
    @keyframes energy-pulse {
      0%, 100% { 
        transform: translate(-50%, -50%) scale(1);
        opacity: 0.3;
      }
      50% { 
        transform: translate(-50%, -50%) scale(1.2);
        opacity: 0.7;
      }
    }
    .manifestation-code {
      font-family: 'Courier New', monospace;
      font-size: 1.2rem;
      letter-spacing: 3px;
      color: var(--neon-magenta);
      text-shadow: 0 0 10px var(--neon-magenta);
    }
    .encryption-indicator {
      color: var(--neon-green);
      font-size: 0.9rem;
      margin-top: 10px;
    }
    .workflow-status {
      background: rgba(0, 255, 0, 0.1);
      border: 1px solid var(--neon-green);
      padding: 10px;
      border-radius: 5px;
      margin-top: 15px;
    }
    .audio-visualizer {
      display: flex;
      align-items: end;
      height: 60px;
      gap: 2px;
      justify-content: center;
      margin: 15px 0;
      display: none;
    }
    .audio-bar {
      width: 4px;
      background: var(--neon-cyan);
      border-radius: 2px;
      animation: audio-dance 0.5s infinite ease-in-out;
    }
    @keyframes audio-dance {
      0%, 100% { height: 10px; }
      50% { height: 40px; }
    }
    /* SEÇÕES DE RITUAL - ESTILOS APRIMORADOS */
    .ritual-section {
      margin: 30px auto;
      padding: 30px;
      border-radius: 15px;
      background: rgba(0, 30, 40, 0.7);
      border: 2px solid;
      text-align: center;
      display: none;
      animation: fadeIn 1s ease-in-out;
    }
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }
    .gnostic-section {
      border-color: var(--neon-green);
      background: rgba(0, 50, 0, 0.3);
    }
    .collapse-section {
      border-color: var(--neon-yellow);
      background: rgba(50, 50, 0, 0.3);
    }
    .release-section {
      border-color: var(--neon-magenta);
      background: rgba(50, 0, 50, 0.3);
    }
    .ritual-title {
      font-size: 1.8rem;
      margin-bottom: 20px;
      text-shadow: 0 0 10px currentColor;
    }
    .gnostic-section .ritual-title { color: var(--neon-green); }
    .collapse-section .ritual-title { color: var(--neon-yellow); }
    .release-section .ritual-title { color: var(--neon-magenta); }
    .timer-display {
      font-size: 2.5rem;
      font-weight: bold;
      margin: 20px 0;
      text-shadow: 0 0 20px currentColor;
    }
    .gnostic-section .timer-display { color: var(--neon-green); }
    .collapse-section .timer-display { color: var(--neon-yellow); }
    .instructions {
      margin: 20px 0;
      line-height: 1.6;
      font-size: 1.1rem;
    }
    .hidden { display: none; }
    .success-message {
      color: var(--neon-green);
      font-weight: bold;
      font-size: 1.2rem;
      margin: 20px 0;
      text-shadow: 0 0 10px var(--neon-green);
    }
    @media (max-width: 768px) {
      .form-grid {
        grid-template-columns: 1fr;
      }
      .visualization-container {
        width: 300px;
        height: 300px;
      }
      .title {
        font-size: 2rem;
      }
      .status-panel, .config-panel {
        position: relative;
        margin: 20px auto;
        max-width: 100%;
      }
      .ritual-section {
        padding: 20px;
        margin: 20px 10px;
      }
    }
  </style>
</head>
<body>
  <div class="quantum-background"></div>
  <div class="main-container">
    <div class="ritual-panel">
      <h1 class="title">🌌 SERVIDOR DO CAOS 🌌</h1>
      <p class="subtitle">"Você não está pedindo. Você está reescrevendo a realidade."</p>
      <form id="manifestForm">
        <div class="form-grid">
          <div class="input-group">
            <label for="intent">🌟 Intenção de Manifestação:</label>
            <textarea id="intent" placeholder="Declare sua intenção no PRESENTE (Ex: 'Eu sou próspero e abundante')" required></textarea>
            <div id="intent-analysis" class="frequency-display hidden"></div>
          </div>
          <div class="input-group">
            <label for="name">🧿 Nome Completo:</label>
            <input type="text" id="name" placeholder="Seu nome completo para cálculo numerológico" required>
          </div>
          <div class="input-group">
            <label for="birthDate">📅 Data de Nascimento:</label>
            <input type="text" id="birthDate" placeholder="DD/MM/AAAA" required>
          </div>
          <div class="input-group">
            <label for="location">🌍 Localização (opcional):</label>
            <input type="text" id="location" placeholder="Cidade, Estado, País">
          </div>
          <div class="input-group">
            <label for="manifestationMode">🔮 Modo de Manifestação:</label>
            <select id="manifestationMode">
              <option value="manifestacao">Manifestação Geral</option>
              <option value="cura">Cura e Saúde</option>
              <option value="protecao">Proteção Energética</option>
              <option value="abundancia">Abundância e Prosperidade</option>
              <option value="amor">Amor e Relacionamentos</option>
              <option value="intuicao">Intuição e Sabedoria</option>
            </select>
          </div>
          <div class="input-group">
            <label>📊 Frequência Solfeggio:</label>
            <div class="solfeggio-frequencies" id="solfeggio-freq">
              <!-- Frequências serão adicionadas via JavaScript -->
            </div>
          </div>
          <div class="input-group">
            <label>🛡️ Pantáculo Arquetípico:</label>
            <select id="pantacleType">
              <option value="none">Nenhum</option>
              <option value="abundance">Abundância (💰)</option>
              <option value="love">Amor (❤️)</option>
              <option value="protection">Proteção (🛡️)</option>
              <option value="wisdom">Sabedoria (🧠)</option>
              <option value="healing">Cura (⚕️)</option>
              <option value="power">Poder (⚡)</option>
            </select>
          </div>
        </div>
        <div class="form-grid">
          <div class="input-group">
            <label for="testimonyPhoto">📸 Foto Testemunha:</label>
            <input type="file" id="testimonyPhoto" accept="image/*">
          </div>
          <div class="input-group">
            <label for="radionicGraphic">🖼️ Gráfico Radiônico:</label>
            <input type="file" id="radionicGraphic" accept="image/*">
          </div>
        </div>
        <div class="button-container">
          <button type="button" id="analyzeBtn" class="button">🔍 ANALISAR INTENÇÃO</button>
          <button type="submit" class="button primary">✨ ATIVAR MANIFESTAÇÃO QUÂNTICA ✨</button>
        </div>
      </form>
      <div id="quantum-display" class="quantum-display">
        <div id="status-text">Aguardando configuração do ritual...</div>
      </div>
      <div class="visualization-container" id="visualization" style="display: none;">
        <canvas id="sacred-geometry" class="sacred-geometry"></canvas>
        <div class="energy-field"></div>
        <div class="merkaba-container">
          <canvas id="merkaba-canvas" class="merkaba-rotation" width="200" height="200"></canvas>
        </div>
        <div class="sigil-container" id="sigil-container">
          <img id="sigil-image" class="sigil-image" alt="Sigilo Quântico">
        </div>
        <div class="witness-container" id="witness-container">
          <img id="witness-image" class="witness-image" alt="Testemunha">
        </div>
        <div class="radiographic-container" id="radiographic-container">
          <img id="radiographic-image" class="radiographic-image" alt="Gráfico Radiestésico">
        </div>
        <div class="pantacle-container" id="pantacle-container">
          <img id="pantacle-image" class="pantacle-image" alt="Pantáculo Arquetípico">
        </div>
      </div>
      <div class="quantum-grid" id="quantum-grid">
        <!-- Qubits serão adicionados via JavaScript -->
      </div>
      <div class="frequency-display">
        <div id="lunar-phase-display">🌙 Calculando fase lunar...</div>
        <div id="frequency-display">📊 Frequência: Não selecionada</div>
        <div id="quantum-code-display" class="manifestation-code">Código quântico será gerado...</div>
        <div id="encryption-status" class="encryption-indicator">🔐 Sistema aguardando dados</div>
      </div>
      <div class="audio-visualizer" id="audio-visualizer">
        <!-- Barras de áudio serão adicionadas via JavaScript -->
      </div>
      <div id="workflow-status" class="workflow-status hidden">
        <h4>🤖 Status do Workflow GitHub Actions:</h4>
        <div id="workflow-info">Aguardando ativação...</div>
      </div>
      <!-- SEÇÃO DE INDUÇÃO GNÓSTICA -->
      <div id="gnostic-section" class="ritual-section gnostic-section">
        <h2 class="ritual-title">🌀 INDUÇÃO DE ESTADO GNÓSTICO</h2>
        <p class="instructions">
          Prepare-se para entrar em um estado alterado de consciência. <br>
          Feche os olhos, respire profundamente e use fones de ouvido. <br>
          Os batimentos binaurais irão guiá-lo para o estado theta ideal para o carregamento.
        </p>
        <div class="timer-display" id="gnostic-timer">3:00</div>
        <button id="startGnosticBtn" class="button gnostic">▶️ INICIAR INDUÇÃO</button>
      </div>
      <!-- SEÇÃO DE COLAPSO DA FUNÇÃO DE ONDA -->
      <div id="collapse-section" class="ritual-section collapse-section">
        <h2 class="ritual-title">👁️‍🗨️ COLAPSO DA FUNÇÃO DE ONDA</h2>
        <p class="instructions">
          Visualize seu desejo <strong>COMO SE JÁ ESTIVESSE REALIZADO</strong>. <br>
          Sinta a emoção, os sons, os cheiros, as texturas. <br>
          Este é o momento de colapsar as infinitas possibilidades em uma única realidade.
        </p>
        <div class="timer-display" id="collapse-timer">0:07</div>
        <button id="collapseBtn" class="button collapse">✨ COLAPSAR AGORA</button>
      </div>
      <!-- SEÇÃO DE LIBERAÇÃO -->
      <div id="release-section" class="ritual-section release-section">
        <h2 class="ritual-title">🌀 LIBERAÇÃO DO SIGILO</h2>
        <p class="instructions">
          Parabéns! Seu sigilo foi carregado com energia gnóstica e colapsado na realidade. <br>
          Agora, <strong>LIBERE TOTALMENTE</strong> este desejo da sua mente consciente. <br>
          Distraia-se completamente. Vá tomar um banho, ouvir música, caminhar. <br>
          O sigilo agora opera no subconsciente e no campo quântico. Confie.
        </p>
        <div class="success-message">
          ✨ "O desejo é morto no momento de sua satisfação." - Austin Osman Spare
        </div>
      </div>
      <div style="margin-top: 2rem;">
        <a href="realizacoes.html" class="button">▶️ VER REALIZAÇÕES</a>
      </div>
    </div>
  </div>
  <div class="status-panel" id="status-panel">
    <h4>📊 Status do Sistema</h4>
    <div id="system-status">Sistema iniciando...</div>
    <div id="energy-level">Nível energético: 0%</div>
    <div id="next-cycle">Próximo ciclo: calculando...</div>
  </div>
  <div class="config-panel">
    <div class="config-toggle" onclick="toggleConfig()">⚙️ Configurações Avançadas</div>
    <form id="config-form">
      <div class="input-group">
        <label for="github-token">🔑 Token GitHub:</label>
        <input type="password" id="github-token" placeholder="ghp_...">
      </div>
      <div class="input-group">
        <label for="repo-owner">👤 Proprietário do Repo:</label>
        <input type="text" id="repo-owner" placeholder="seu-usuario">
      </div>
      <div class="input-group">
        <label for="repo-name">📁 Nome do Repo:</label>
        <input type="text" id="repo-name" placeholder="tecnomagia-servidor">
      </div>
      <button type="button" onclick="saveConfig()" class="button">💾 Salvar Configurações</button>
    </form>
  </div>
  <!-- Web Audio API para síntese de frequências -->
  <script>
    // Constantes e configurações globais
    const SOLFEGGIO_FREQUENCIES = {
      'UT': { freq: 396, desc: 'Liberação de Culpa' },
      'RE': { freq: 417, desc: 'Facilitando Mudança' },
      'MI': { freq: 528, desc: 'Transformação DNA' },
      'FA': { freq: 639, desc: 'Conexão e Amor' },
      'SOL': { freq: 741, desc: 'Despertar Intuição' },
      'LA': { freq: 852, desc: 'Retorno Espiritual' },
      'SI': { freq: 963, desc: 'Conexão Cósmica' },
      'OM': { freq: 432, desc: 'Frequência Universal' }
    };
    const ASTRO_TIMES = [
      { h: 4, m: 30 }, { h: 7, m: 30 }, { h: 12, m: 0 },
      { h: 15, m: 30 }, { h: 19, m: 30 }, { h: 22, m: 0 }
    ];
    const PANTACLES = {
      'abundance': 'https://upload.wikimedia.org/wikipedia/commons/thumb/4/48/Seal_of_Jupiter.svg/200px-Seal_of_Jupiter.svg.png',
      'love': 'https://upload.wikimedia.org/wikipedia/commons/thumb/5/5c/Seal_of_Venus.svg/200px-Seal_of_Venus.svg.png',
      'protection': 'https://upload.wikimedia.org/wikipedia/commons/thumb/3/3d/Seal_of_Saturn.svg/200px-Seal_of_Saturn.svg.png',
      'wisdom': 'https://upload.wikimedia.org/wikipedia/commons/thumb/0/0f/Seal_of_Mercury.svg/200px-Seal_of_Mercury.svg.png',
      'healing': 'https://upload.wikimedia.org/wikipedia/commons/thumb/1/1f/Seal_of_the_Sun.svg/200px-Seal_of_the_Sun.svg.png',
      'power': 'https://upload.wikimedia.org/wikipedia/commons/thumb/6/6d/Seal_of_Mars.svg/200px-Seal_of_Mars.svg.png'
    };
    let audioContext;
    let currentOscillator;
    let selectedFrequency = 528;
    let isManifesting = false;
    let quantumCode = '';
    let sigilData = null;
    let gnosticTimerInterval = null;
    let collapseTimerInterval = null;
    // Inicialização do sistema
    document.addEventListener('DOMContentLoaded', function() {
      console.log('Sistema iniciando...');
      initializeSystem();
      setupEventListeners();
      createQuantumGrid();
      createSolfeggioButtons();
      startQuantumAnimation();
      loadStoredConfig();
    });
    function initializeSystem() {
      updateSystemStatus('Sistema iniciado');
      calculateLunarPhase();
      updateNextCycle();
      // Inicializar Web Audio API (com interação do usuário)
      document.body.addEventListener('click', function() {
        if (!audioContext) {
          if (typeof AudioContext !== 'undefined') {
            audioContext = new AudioContext();
          } else if (typeof webkitAudioContext !== 'undefined') {
            audioContext = new webkitAudioContext();
          }
          if (audioContext) {
            updateSystemStatus('Web Audio API ativada');
          }
        }
      }, { once: true });
      // Gerar chave de criptografia
      const encryptionKey = generateEncryptionKey();
      updateEncryptionStatus('Sistema criptográfico ativo');
    }
    function setupEventListeners() {
      const form = document.getElementById('manifestForm');
      const analyzeBtn = document.getElementById('analyzeBtn');
      const intentInput = document.getElementById('intent');
      const testimonyPhoto = document.getElementById('testimonyPhoto');
      const startGnosticBtn = document.getElementById('startGnosticBtn');
      const collapseBtn = document.getElementById('collapseBtn');
      form.addEventListener('submit', handleManifestationSubmit);
      analyzeBtn.addEventListener('click', analyzeIntention);
      intentInput.addEventListener('input', debounce(analyzeIntentionRealTime, 1000));
      testimonyPhoto.addEventListener('change', handleTestimonyUpload);
      if (startGnosticBtn) {
        startGnosticBtn.addEventListener('click', startGnosticInduction);
      }
      if (collapseBtn) {
        collapseBtn.addEventListener('click', handleCollapseReality);
      }
      // Event listeners para frequências Solfeggio
      document.addEventListener('click', function(e) {
        if (e.target.classList.contains('freq-button')) {
          selectFrequency(e.target);
        }
      });
    }
    function createQuantumGrid() {
      const grid = document.getElementById('quantum-grid');
      if (!grid) return;
      grid.innerHTML = '';
      for (let i = 0; i < 81; i++) {
        const qubit = document.createElement('div');
        qubit.className = 'qubit';
        qubit.dataset.index = i;
        grid.appendChild(qubit);
      }
    }
    function createSolfeggioButtons() {
      const container = document.getElementById('solfeggio-freq');
      if (!container) return;
      container.innerHTML = '';
      Object.entries(SOLFEGGIO_FREQUENCIES).forEach(([key, data]) => {
        const button = document.createElement('button');
        button.type = 'button';
        button.className = 'freq-button';
        button.dataset.frequency = data.freq;
        button.textContent = `${key} (${data.freq}Hz)`;
        button.title = data.desc;
        if (data.freq === selectedFrequency) {
          button.classList.add('active');
        }
        container.appendChild(button);
      });
    }
    function selectFrequency(button) {
      document.querySelectorAll('.freq-button').forEach(btn => btn.classList.remove('active'));
      button.classList.add('active');
      selectedFrequency = parseInt(button.dataset.frequency);
      updateFrequencyDisplay();
      if (audioContext) {
        playFrequency(selectedFrequency, 1000);
      }
    }
    function updateFrequencyDisplay() {
      const display = document.getElementById('frequency-display');
      if (!display) return;
      const freqInfo = Object.values(SOLFEGGIO_FREQUENCIES).find(f => f.freq === selectedFrequency);
      display.textContent = `📊 Frequência: ${selectedFrequency}Hz - ${freqInfo ? freqInfo.desc : 'Personalizada'}`;
    }
    function playFrequency(frequency, duration = 2000) {
      if (!audioContext) {
        updateSystemStatus('⚠️ Clique em qualquer lugar da página para ativar o áudio');
        return;
      }
      if (currentOscillator) {
        currentOscillator.stop();
      }
      currentOscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      currentOscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);
      currentOscillator.frequency.value = frequency;
      currentOscillator.type = 'sine';
      gainNode.gain.setValueAtTime(0, audioContext.currentTime);
      gainNode.gain.linearRampToValueAtTime(0.3, audioContext.currentTime + 0.1);
      gainNode.gain.linearRampToValueAtTime(0.3, audioContext.currentTime + duration/1000 - 0.1);
      gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + duration/1000);
      currentOscillator.start(audioContext.currentTime);
      currentOscillator.stop(audioContext.currentTime + duration/1000);
      showAudioVisualizer(duration);
    }
    function showAudioVisualizer(duration) {
      const visualizer = document.getElementById('audio-visualizer');
      if (!visualizer) return;
      visualizer.style.display = 'flex';
      visualizer.innerHTML = '';
      for (let i = 0; i < 20; i++) {
        const bar = document.createElement('div');
        bar.className = 'audio-bar';
        bar.style.animationDelay = `${i * 50}ms`;
        bar.style.animationDuration = `${Math.random() * 0.5 + 0.3}s`;
        visualizer.appendChild(bar);
      }
      setTimeout(() => {
        visualizer.style.display = 'none';
      }, duration);
    }
    function analyzeIntention() {
      const intent = document.getElementById('intent').value.trim();
      if (!intent) {
        alert('⚠️ Digite sua intenção primeiro!');
        return;
      }
      const analysis = performIntentionAnalysis(intent);
      displayAnalysisResults(analysis);
    }
    function analyzeIntentionRealTime() {
      const intent = document.getElementById('intent').value.trim();
      if (intent.length > 10) {
        const analysis = performIntentionAnalysis(intent);
        displayQuickAnalysis(analysis);
      }
    }
    function performIntentionAnalysis(text) {
      const words = text.toLowerCase().split(/\s+/);
      const powerWords = [
        'sou', 'tenho', 'recebo', 'manifesto', 'crio', 'realizo',
        'atraio', 'abundância', 'prosperidade', 'alegria', 'saúde',
        'amor', 'sucesso', 'harmonia', 'paz', 'gratidão', 'agora',
        'já', 'presente', 'realidade', 'concretizado', 'pleno'
      ];
      const limitingWords = [
        'não', 'nunca', 'jamais', 'impossível', 'difícil', 'problema',
        'dificuldade', 'quero', 'desejo', 'preciso', 'necessito', 'talvez',
        'tentarei', 'espero', 'dúvida', 'medo', 'preocupação', 'ansiedade'
      ];
      const powerCount = words.filter(w => powerWords.includes(w)).length;
      const limitingCount = words.filter(w => limitingWords.includes(w)).length;
      const presentTense = words.some(w => ['sou', 'estou', 'tenho', 'recebo'].includes(w));
      const futureTense = words.some(w => ['serei', 'estarei', 'terei', 'receberei'].includes(w));
      let score = 50;
      if (words.length > 0) {
        score += (powerCount / words.length) * 30;
        score -= (limitingCount / words.length) * 40;
      }
      if (presentTense) score += 20;
      if (futureTense) score -= 15;
      score = Math.max(0, Math.min(100, score));
      return {
        score: Math.round(score),
        powerWords: powerCount,
        limitingWords: limitingCount,
        presentTense,
        futureTense,
        totalWords: words.length,
        suggestions: generateSuggestions(score, limitingCount, presentTense, futureTense)
      };
    }
    function generateSuggestions(score, limitingCount, presentTense, futureTense) {
      const suggestions = [];
      if (score < 50) {
        suggestions.push('Reformule usando afirmações positivas no presente');
      }
      if (limitingCount > 0) {
        suggestions.push('Evite palavras negativas ou limitantes');
      }
      if (futureTense && !presentTense) {
        suggestions.push('Use o tempo presente em vez do futuro');
      }
      if (score < 70) {
        suggestions.push('Adicione mais palavras de poder e certeza');
      }
      return suggestions;
    }
    function displayAnalysisResults(analysis) {
      const container = document.getElementById('intent-analysis');
      if (!container) return;
      container.classList.remove('hidden');
      let statusClass = 'low';
      let statusText = 'PRECISA MELHORAR';
      let statusEmoji = '🔴';
      if (analysis.score >= 90) {
        statusClass = 'excellent';
        statusText = 'EXCELENTE';
        statusEmoji = '✅';
      } else if (analysis.score >= 70) {
        statusClass = 'good';
        statusText = 'BOM';
        statusEmoji = '🟢';
      } else if (analysis.score >= 50) {
        statusClass = 'medium';
        statusText = 'MÉDIO';
        statusEmoji = '🟡';
      }
      let html = `
        <h4>🔍 Análise da Intenção</h4>
        <div style="color: var(--neon-${statusClass === 'excellent' ? 'green' : statusClass === 'good' ? 'cyan' : statusClass === 'medium' ? 'yellow' : 'magenta'});">
          ${statusEmoji} Status: ${statusText} (${analysis.score}/100)
        </div>
        <div>💪 Palavras de poder: ${analysis.powerWords}</div>
        <div>⚠️ Palavras limitantes: ${analysis.limitingWords}</div>
        <div>⏰ Tempo presente: ${analysis.presentTense ? '✅ Sim' : '❌ Não'}</div>
      `;
      if (analysis.suggestions.length > 0) {
        html += '<div style="margin-top: 10px;"><strong>📝 Sugestões:</strong><ul>';
        analysis.suggestions.forEach(suggestion => {
          html += `<li>${suggestion}</li>`;
        });
        html += '</ul></div>';
      }
      container.innerHTML = html;
    }
    function displayQuickAnalysis(analysis) {
      const container = document.getElementById('intent-analysis');
      if (!container) return;
      container.classList.remove('hidden');
      container.innerHTML = `
        <div style="font-size: 0.9em; opacity: 0.8;">
          Análise rápida: ${analysis.score}/100 pontos
        </div>
      `;
    }
    async function handleManifestationSubmit(e) {
      e.preventDefault();
      if (isManifesting) {
        alert('⚠️ Manifestação já em andamento. Aguarde a conclusão.');
        return;
      }
      const formData = collectFormData();
      if (!validateFormData(formData)) {
        return;
      }
      isManifesting = true;
      updateSystemStatus('Iniciando processo de manifestação...');
      try {
        await processManifestationRitual(formData);
      } catch (error) {
        console.error('Erro no ritual:', error);
        updateSystemStatus(`Erro: ${error.message}`);
      } finally {
        isManifesting = false;
      }
    }
    function collectFormData() {
      return {
        intent: document.getElementById('intent').value.trim(),
        name: document.getElementById('name').value.trim(),
        birthDate: document.getElementById('birthDate').value.trim(),
        location: document.getElementById('location').value.trim(),
        mode: document.getElementById('manifestationMode').value,
        frequency: selectedFrequency,
        testimonyPhoto: document.getElementById('testimonyPhoto').files[0],
        radionicGraphic: document.getElementById('radionicGraphic').files[0],
        pantacleType: document.getElementById('pantacleType').value
      };
    }
    function validateFormData(data) {
      if (!data.intent || !data.name || !data.birthDate) {
        alert('⚠️ Preencha todos os campos obrigatórios!');
        return false;
      }
      if (!/^\d{2}\/\d{2}\/\d{4}$/.test(data.birthDate)) {
        alert('⚠️ Data de nascimento deve estar no formato DD/MM/AAAA');
        return false;
      }
      return true;
    }
    async function processManifestationRitual(formData) {
      try {
        // Fase 1: Preparação
        updateSystemStatus('Fase 1: Preparando campos quânticos...');
        await sleep(1000);
        // Calcular numerologia
        const numerology = calculateAdvancedNumerology(formData.name, formData.birthDate);
        quantumCode = generateQuantumCode(formData.intent, formData.name, formData.birthDate);
        // Criar Sigilo
        sigilData = generateAustinSpareSigil(formData.intent);
        // Criptografar dados
        const encryptedData = encryptManifestationData(formData, quantumCode);
        updateEncryptionStatus(`Dados criptografados com chave quântica`);
        // Fase 2: Ativação energética
        updateSystemStatus('Fase 2: Ativando qubits...');
        await activateQuantumGrid(numerology.destinyNumber);
        // Fase 3: Sincronização de frequência
        updateSystemStatus('Fase 3: Sincronizando frequências Solfeggio...');
        await playManifestationFrequency(formData.frequency);
        // Fase 4: Visualização
        updateSystemStatus('Fase 4: Gerando visualizações sagradas...');
        await startVisualization(formData, numerology, quantumCode, sigilData);
        // Fase 5: Upload para GitHub
        updateSystemStatus('Fase 5: Criando registro quântico...');
        await createGitHubIssue(encryptedData, quantumCode, sigilData);
        // Fase 6: Ativação do workflow
        await triggerEnergyWorkflow(quantumCode);
        // Exibir resultados
        displayManifestationResults(formData, numerology, quantumCode);
        updateSystemStatus('✅ Manifestação preparada! Iniciando fase de indução gnóstica...');
        // MOSTRAR SEÇÃO DE INDUÇÃO GNÓSTICA
        showRitualSection('gnostic-section');
      } catch (error) {
        throw new Error(`Falha no ritual: ${error.message}`);
      }
    }
    function showRitualSection(sectionId) {
      const section = document.getElementById(sectionId);
      if (section) {
        section.style.display = 'block';
        console.log(`Seção ${sectionId} exibida.`);
      } else {
        console.error(`Seção ${sectionId} não encontrada.`);
      }
    }
    async function startGnosticInduction() {
      updateSystemStatus('Iniciando Indução de Estado Gnóstico...');
      const startBtn = document.getElementById('startGnosticBtn');
      if (startBtn) startBtn.disabled = true;
      // Reproduzir batimentos binaurais
      playBinauralBeats(200, 4, 180);
      // Iniciar contador
      let seconds = 180;
      const timerElement = document.getElementById('gnostic-timer');
      gnosticTimerInterval = setInterval(() => {
        seconds--;
        const mins = Math.floor(seconds / 60);
        const secs = seconds % 60;
        if (timerElement) {
          timerElement.textContent = `${mins}:${secs < 10 ? '0' + secs : secs}`;
        }
        if (seconds <= 0) {
          clearInterval(gnosticTimerInterval);
          updateSystemStatus('✅ Estado Gnóstico Alcançado!');
          showRitualSection('collapse-section');
        }
      }, 1000);
    }
    function playBinauralBeats(baseFreq, beatFreq, duration) {
      if (!audioContext) return;
      const totalSamples = audioContext.sampleRate * duration;
      const leftChannel = audioContext.createBuffer(1, totalSamples, audioContext.sampleRate);
      const rightChannel = audioContext.createBuffer(1, totalSamples, audioContext.sampleRate);
      const leftData = leftChannel.getChannelData(0);
      const rightData = rightChannel.getChannelData(0);
      for (let i = 0; i < totalSamples; i++) {
        const t = i / audioContext.sampleRate;
        leftData[i] = 0.3 * Math.sin(2 * Math.PI * baseFreq * t);
        rightData[i] = 0.3 * Math.sin(2 * Math.PI * (baseFreq + beatFreq) * t);
      }
      const leftSource = audioContext.createBufferSource();
      const rightSource = audioContext.createBufferSource();
      const merger = audioContext.createChannelMerger(2);
      leftSource.buffer = leftChannel;
      rightSource.buffer = rightChannel;
      leftSource.connect(merger, 0, 0);
      rightSource.connect(merger, 0, 1);
      merger.connect(audioContext.destination);
      leftSource.start();
      rightSource.start();
      setTimeout(() => {
        leftSource.stop();
        rightSource.stop();
      }, duration * 1000);
    }
    async function handleCollapseReality() {
      updateSystemStatus('👁️‍🗨️ Observação Colapsante em andamento...');
      const collapseBtn = document.getElementById('collapseBtn');
      if (collapseBtn) collapseBtn.disabled = true;
      // Reproduzir frequências de colapso
      playFrequency(741, 7000);
      await sleep(1000);
      playFrequency(852, 6000);
      // Animação de colapso
      const container = document.getElementById('visualization');
      if (container) {
        container.style.animation = 'collapse-animation 7s forwards';
        const style = document.createElement('style');
        style.innerHTML = `
          @keyframes collapse-animation {
            0% { transform: scale(1); filter: brightness(1); }
            50% { transform: scale(1.2); filter: brightness(1.5); }
            100% { transform: scale(0.8); filter: brightness(0.5); }
          }
        `;
        document.head.appendChild(style);
      }
      // Iniciar contador de 7 segundos
      let seconds = 7;
      const timerElement = document.getElementById('collapse-timer');
      collapseTimerInterval = setInterval(() => {
        seconds--;
        if (timerElement) {
          timerElement.textContent = `0:${seconds < 10 ? '0' + seconds : seconds}`;
        }
        if (seconds <= 0) {
          clearInterval(collapseTimerInterval);
          updateSystemStatus('✅ Realidade colapsada!');
          showRitualSection('release-section');
        }
      }, 1000);
    }
    function calculateAdvancedNumerology(name, birthDate) {
      const nameValue = name.toLowerCase()
        .split('')
        .reduce((sum, char) => {
          if (char >= 'a' && char <= 'z') {
            return sum + (char.charCodeAt(0) - 96);
          }
          return sum;
        }, 0);
      const [day, month, year] = birthDate.split('/').map(Number);
      const dateValue = day + month + year;
      let destinyNumber = (nameValue * dateValue) % 108;
      while (destinyNumber > 9) {
        destinyNumber = destinyNumber.toString().split('').reduce((sum, digit) => sum + parseInt(digit), 0);
      }
      if (destinyNumber === 0) destinyNumber = 9;
      const vowels = name.toLowerCase().match(/[aeiou]/g) || [];
      const consonants = name.toLowerCase().match(/[bcdfghjklmnpqrstvwxyz]/g) || [];
      const soulNumber = vowels.reduce((sum, v) => sum + ({'a':1,'e':5,'i':9,'o':6,'u':3}[v] || 0), 0) % 9 || 9;
      const personalityNumber = consonants.length % 9 || 9;
      return {
        destinyNumber,
        soulNumber,
        personalityNumber,
        nameValue,
        dateValue
      };
    }
    function generateQuantumCode(intent, name, birthDate) {
      const seed = intent + name + birthDate + Date.now().toString();
      let hash = 0;
      for (let i = 0; i < seed.length; i++) {
        const char = seed.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash;
      }
      const lunarPhase = calculateLunarPhase();
      hash = (hash + Math.floor(lunarPhase * 100)) % 1000000000000;
      const codeStr = Math.abs(hash).toString().padStart(12, '0');
      return `${codeStr.slice(0,4)}-${codeStr.slice(4,8)}-${codeStr.slice(8,12)}`;
    }
    function generateAustinSpareSigil(intent) {
      let statement = intent.toLowerCase();
      let condensed = statement.replace(/[aeiou\s]/g, '');
      condensed = condensed.replace(/(.)\1+/g, '$1');
      let pathData = "M10,50";
      for (let i = 0; i < condensed.length; i++) {
        const charCode = condensed.charCodeAt(i);
        const x = 20 + i * 30;
        const y = 50 + ((charCode % 10) - 5) * 10;
        pathData += ` L${x},${y}`;
      }
      const svg = `
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 200 100" width="200" height="100">
          <rect width="200" height="100" fill="black"/>
          <path d="${pathData}" fill="none" stroke="yellow" stroke-width="3"/>
        </svg>
      `;
      const sigilUrl = 'image/svg+xml;base64,' + btoa(svg);
      return {
        originalIntent: intent,
        condensed: condensed,
        sigilUrl: sigilUrl
      };
    }
    function generateEncryptionKey() {
      const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
      let result = '';
      for (let i = 0; i < 32; i++) {
        result += chars.charAt(Math.floor(Math.random() * chars.length));
      }
      return result;
    }
    function encryptManifestationData(data, quantumCode) {
      const rawData = {
        intent: data.intent,
        name: data.name,
        birthDate: data.birthDate,
        location: data.location,
        mode: data.mode,
        frequency: data.frequency,
        timestamp: Date.now(),
        quantumCode,
        pantacleType: data.pantacleType
      };
      let dataStr = JSON.stringify(rawData);
      const shift = quantumCode.split('').reduce((sum, char) => sum + char.charCodeAt(0), 0) % 26;
      dataStr = dataStr.split('').map(char => 
        String.fromCharCode(char.charCodeAt(0) + shift)
      ).join('');
      function utf8ToB64(str) {
        const utf8Bytes = new TextEncoder().encode(str);
        const binaryString = String.fromCharCode.apply(null, utf8Bytes);
        return btoa(binaryString);
      }
      try {
        return utf8ToB64(dataStr);
      } catch (error) {
        console.error('Erro ao criptografar dados:', error);
        const latin1Str = dataStr.replace(/[^\x00-\xFF]/g, '?');
        return btoa(latin1Str);
      }
    }
    async function activateQuantumGrid(destinyNumber) {
      const qubits = document.querySelectorAll('.qubit');
      const pattern = generateActivationPattern(destinyNumber);
      for (let i = 0; i < pattern.length; i++) {
        await sleep(100);
        qubits.forEach((qubit, index) => {
          qubit.classList.remove('active');
          if (pattern[i].includes(index)) {
            qubit.classList.add('active');
          }
        });
        updateEnergyLevel(Math.min(100, (i + 1) * 10));
      }
    }
    function generateActivationPattern(destinyNumber) {
      const patterns = [];
      const totalQubits = 81;
      for (let phase = 0; phase < 10; phase++) {
        const pattern = [];
        const numActive = (destinyNumber + phase) % 9 + 1;
        for (let i = 0; i < numActive; i++) {
          const index = (destinyNumber * (phase + 1) * (i + 1)) % totalQubits;
          if (!pattern.includes(index)) {
            pattern.push(index);
          }
        }
        patterns.push(pattern);
      }
      return patterns;
    }
    async function playManifestationFrequency(frequency) {
      if (!audioContext) return;
      updateSystemStatus(`Emitindo ${frequency}Hz...`);
      const harmonics = [frequency, frequency * 1.618, frequency * 2, frequency * 2.618];
      for (let i = 0; i < harmonics.length; i++) {
        await sleep(500);
        playFrequency(harmonics[i], 2000);
      }
      showAudioVisualizer(8000);
    }
    async function startVisualization(formData, numerology, quantumCode, sigilData) {
      const container = document.getElementById('visualization');
      if (container) container.style.display = 'block';
      const display = document.getElementById('quantum-display');
      if (display) {
        display.innerHTML = `
          <div style="text-align: center;">
            <div class="manifestation-code">✨ ${quantumCode} ✨</div>
            <div>🧿 Número de Destino: ${numerology.destinyNumber}</div>
            <div>🔮 Modo: ${formData.mode.toUpperCase()}</div>
            <div>📊 Frequência: ${formData.frequency}Hz</div>
            <div style="margin-top: 15px; color: var(--neon-green);">
              🌀 Campo quântico estabilizado - Manifestação em processo...
            </div>
          </div>
        `;
      }
      drawSacredGeometry();
      drawMerkaba();
      await setupQuantumSigil(sigilData.sigilUrl);
      if (formData.testimonyPhoto) {
        await setupWitnessImage(formData.testimonyPhoto);
      }
      if (formData.radionicGraphic) {
        await setupRadiographicImage(formData.radionicGraphic);
      }
      if (formData.pantacleType && formData.pantacleType !== 'none') {
        await setupPantacle(formData.pantacleType);
      }
    }
    async function setupQuantumSigil(sigilUrl) {
      const container = document.getElementById('sigil-container');
      const image = document.getElementById('sigil-image');
      if (container && image) {
        image.src = sigilUrl;
        container.style.display = 'block';
      }
    }
    async function setupRadiographicImage(file) {
      const container = document.getElementById('radiographic-container');
      const image = document.getElementById('radiographic-image');
      if (container && image) {
        const reader = new FileReader();
        reader.onload = function(e) {
          image.src = e.target.result;
          container.style.display = 'block';
        };
        reader.readAsDataURL(file);
      }
    }
    async function setupWitnessImage(file) {
      const container = document.getElementById('witness-container');
      const image = document.getElementById('witness-image');
      if (container && image) {
        const reader = new FileReader();
        reader.onload = function(e) {
          image.src = e.target.result;
          container.style.display = 'block';
        };
        reader.readAsDataURL(file);
      }
    }
    async function setupPantacle(pantacleType) {
      const container = document.getElementById('pantacle-container');
      const image = document.getElementById('pantacle-image');
      if (container && image && PANTACLES[pantacleType]) {
        image.src = PANTACLES[pantacleType];
        container.style.display = 'block';
      }
    }
    function drawSacredGeometry() {
      const canvas = document.getElementById('sacred-geometry');
      if (!canvas) return;
      const ctx = canvas.getContext('2d');
      canvas.width = canvas.offsetWidth;
      canvas.height = canvas.offsetHeight;
      let rotation = 0;
      function animate() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        ctx.strokeStyle = 'rgba(0, 255, 255, 0.3)';
        ctx.lineWidth = 1;
        const baseRadius = 50;
        const centers = [{x: centerX, y: centerY}];
        for (let i = 0; i < 6; i++) {
          const angle = (2 * Math.PI * i / 6) + rotation * 0.01;
          const x = centerX + baseRadius * Math.cos(angle);
          const y = centerY + baseRadius * Math.sin(angle);
          centers.push({x, y});
        }
        for (let i = 0; i < 12; i++) {
          const angle = (2 * Math.PI * i / 12) + rotation * 0.005;
          const x = centerX + baseRadius * 1.618 * Math.cos(angle);
          const y = centerY + baseRadius * 1.618 * Math.sin(angle);
          centers.push({x, y});
        }
        centers.forEach((center, index) => {
          const alpha = 0.3 + 0.4 * ((index % 7) / 6);
          ctx.beginPath();
          ctx.arc(center.x, center.y, baseRadius * 0.8, 0, 2 * Math.PI);
          ctx.strokeStyle = `rgba(0, 255, 255, ${alpha})`;
          ctx.stroke();
        });
        ctx.strokeStyle = 'rgba(255, 255, 0, 0.5)';
        ctx.lineWidth = 2;
        const metatronRadius = baseRadius * 2.618;
        for (let i = 0; i < 13; i++) {
          const angle1 = (2 * Math.PI * i / 13) + rotation * 0.015;
          const x1 = centerX + metatronRadius * Math.cos(angle1);
          const y1 = centerY + metatronRadius * Math.sin(angle1);
          for (let j = i + 1; j < 13; j++) {
            const angle2 = (2 * Math.PI * j / 13) + rotation * 0.015;
            const x2 = centerX + metatronRadius * Math.cos(angle2);
            const y2 = centerY + metatronRadius * Math.sin(angle2);
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
          }
        }
        ctx.strokeStyle = 'rgba(255, 255, 0, 0.4)';
        ctx.beginPath();
        const phi = 1.618033988749895;
        for (let i = 0; i < 200; i++) {
          const angle = i * 0.1 + rotation * 0.02;
          const r = i * phi * 0.5;
          const x = centerX + r * Math.cos(angle);
          const y = centerY + r * Math.sin(angle);
          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        ctx.stroke();
        rotation++;
        requestAnimationFrame(animate);
      }
      animate();
    }
    function drawMerkaba() {
      const canvas = document.getElementById('merkaba-canvas');
      if (!canvas) return;
      const ctx = canvas.getContext('2d');
      let rotation = 0;
      function animate() {
        ctx.clearRect(0, 0, 200, 200);
        const centerX = 100;
        const centerY = 100;
        const size = 60;
        ctx.strokeStyle = '#00ffff';
        ctx.lineWidth = 2;
        ctx.beginPath();
        for (let i = 0; i < 3; i++) {
          const angle = (2 * Math.PI * i / 3) + rotation * 0.02;
          const x = centerX + size * Math.cos(angle);
          const y = centerY + size * Math.sin(angle);
          if (i === 0) ctx.moveTo(centerX, centerY - size);
          ctx.lineTo(x, y + 20);
        }
        ctx.closePath();
        ctx.stroke();
        ctx.strokeStyle = '#ff00ff';
        ctx.beginPath();
        for (let i = 0; i < 3; i++) {
          const angle = (2 * Math.PI * i / 3) - rotation * 0.02;
          const x = centerX + size * Math.cos(angle);
          const y = centerY + size * Math.sin(angle);
          if (i === 0) ctx.moveTo(centerX, centerY + size);
          ctx.lineTo(x, y - 20);
        }
        ctx.closePath();
        ctx.stroke();
        rotation++;
        requestAnimationFrame(animate);
      }
      animate();
    }
    async function createGitHubIssue(encryptedData, quantumCode, sigilData) {
      const config = getStoredConfig();
      if (!config.token || !config.owner || !config.repo) {
        updateSystemStatus('⚠️ Configure GitHub para ativação completa');
        return;
      }
      const issueTitle = `Manifestação Quântica: ${quantumCode}`;
      const issueBody = `
# 🌌 Registro de Manifestação Quântica
**Código Quântico:** \`${quantumCode}\`
**Timestamp:** ${new Date().toISOString()}
**Status:** Ativo
**Sigilo (Método Spare):** \`${sigilData.condensed}\`
## Dados Criptografados
\`\`\`
${encryptedData}
\`\`\`
## Instruções para o Workflow
Este registro ativa automaticamente o sistema de energização contínua.
O workflow executará emissões de energia em intervalos regulares até a manifestação.
*Sistema de Tecnomagia Quântica - Servidor do Caos*
      `;
      try {
        const response = await fetch(`https://api.github.com/repos/${config.owner}/${config.repo}/issues`, {
          method: 'POST',
          headers: {
            'Authorization': `token ${config.token}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            title: issueTitle,
            body: issueBody,
            labels: ['manifestacao-ativa', 'quantum-entangled', 'energia-continua', 'campo-morfogenetico', 'sigilo-spare']
          })
        });
        if (response.ok) {
          const issue = await response.json();
          updateSystemStatus(`✅ Registro quântico criado: #${issue.number}`);
          return issue;
        } else {
          throw new Error(`GitHub API error: ${response.status}`);
        }
      } catch (error) {
        console.error('Erro ao criar issue:', error);
        updateSystemStatus(`❌ Erro no registro: ${error.message}`);
      }
    }
    async function triggerEnergyWorkflow(quantumCode) {
      const config = getStoredConfig();
      if (!config.token) {
        const workflowStatus = document.getElementById('workflow-status');
        const workflowInfo = document.getElementById('workflow-info');
        if (workflowStatus && workflowInfo) {
          workflowStatus.classList.remove('hidden');
          workflowInfo.innerHTML = `
            <div>📋 Configure GitHub para ativação automática</div>
            <div>🔄 Workflow manual: Execute energização a cada 4 horas</div>
            <div>⏰ Próxima energização recomendada: ${getNextEnergyTime()}</div>
          `;
        }
        return;
      }
      try {
        const response = await fetch(`https://api.github.com/repos/${config.owner}/${config.repo}/dispatches`, {
          method: 'POST',
          headers: {
            'Authorization': `token ${config.token}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            event_type: 'energize_manifestation',
            client_payload: {
              quantum_code: quantumCode,
              timestamp: Date.now()
            }
          })
        });
        const workflowStatus = document.getElementById('workflow-status');
        const workflowInfo = document.getElementById('workflow-info');
        if (workflowStatus && workflowInfo) {
          workflowStatus.classList.remove('hidden');
          if (response.ok) {
            workflowInfo.innerHTML = `
              <div>✅ Workflow de energização ativado</div>
              <div>🤖 Sistema executará automaticamente</div>
              <div>⏰ Próxima execução: ${getNextEnergyTime()}</div>
              <div>🔄 Frequência: A cada 4 horas</div>
              <div style="color: var(--neon-yellow); margin-top: 10px;">
                ✨ Ancoragem temporal e reforço de campo morfogenético em operação.
              </div>
            `;
          } else {
            throw new Error(`Dispatch failed: ${response.status}`);
          }
        }
      } catch (error) {
        console.error('Erro ao ativar workflow:', error);
        const workflowInfo = document.getElementById('workflow-info');
        if (workflowInfo) {
          workflowInfo.innerHTML = `
            <div>⚠️ Workflow manual necessário</div>
            <div>📋 Execute scripts de energização manualmente</div>
          `;
        }
      }
    }
    function displayManifestationResults(formData, numerology, quantumCode) {
      const correspondences = getHermeticCorrespondences(numerology.destinyNumber);
      const resultsHTML = `
        <div style="text-align: left; margin-top: 20px;">
          <h3>🌟 Manifestação Carregada com Sucesso!</h3>
          <div style="margin: 15px 0;">
            <strong>🔮 Informações Numerológicas:</strong><br>
            • Número de Destino: ${numerology.destinyNumber}<br>
            • Número da Alma: ${numerology.soulNumber}<br>
            • Número da Personalidade: ${numerology.personalityNumber}
          </div>
          <div style="margin: 15px 0;">
            <strong>🌿 Correspondências Herméticas:</strong><br>
            • Elemento: ${correspondences.element}<br>
            • Planeta: ${correspondences.planet}<br>
            • Pedra: ${correspondences.stone}<br>
            • Chakra: ${correspondences.chakra}
          </div>
          <div style="margin: 15px 0;">
            <strong>📋 Instruções para Potencializar:</strong><br>
            1. Visualize seu objetivo realizado por 5 min diários<br>
            2. Repita o código ${quantumCode} 3x ao acordar/dormir<br>
            3. Use pedras: ${correspondences.stone}<br>
            4. Trabalhe o chakra: ${correspondences.chakra}<br>
            5. Mantenha gratidão pelo que já possui
          </div>
          <div style="color: var(--neon-yellow); margin-top: 20px; font-weight: bold;">
            ✨ O sistema continuará energizando sua manifestação automaticamente!
          </div>
        </div>
      `;
      const display = document.getElementById('quantum-display');
      if (display) {
        display.innerHTML = resultsHTML;
      }
    }
    function getHermeticCorrespondences(destinyNumber) {
      const correspondences = {
        1: { element: 'Fogo', planet: 'Sol', stone: 'Rubi, Diamante', chakra: 'Plexo Solar' },
        2: { element: 'Água', planet: 'Lua', stone: 'Pérola, Selenita', chakra: 'Sacral' },
        3: { element: 'Ar', planet: 'Júpiter', stone: 'Safira, Turquesa', chakra: 'Garganta' },
        4: { element: 'Terra', planet: 'Saturno', stone: 'Jade, Esmeralda', chakra: 'Raiz' },
        5: { element: 'Fogo', planet: 'Mercúrio', stone: 'Ágata, Citrino', chakra: 'Plexo Solar' },
        6: { element: 'Ar', planet: 'Vênus', stone: 'Esmeralda, Quartzo Rosa', chakra: 'Cardíaco' },
        7: { element: 'Água', planet: 'Netuno', stone: 'Ametista, Fluorita', chakra: 'Terceiro Olho' },
        8: { element: 'Terra', planet: 'Saturno', stone: 'Obsidiana, Ônix', chakra: 'Raiz' },
        9: { element: 'Fogo', planet: 'Marte', stone: 'Granada, Rubi', chakra: 'Coronário' }
      };
      return correspondences[destinyNumber] || correspondences[9];
    }
    function calculateLunarPhase() {
      const now = new Date();
      const year = now.getFullYear();
      const month = now.getMonth() + 1;
      const day = now.getDate();
      let r = year % 100;
      r %= 19;
      if (r > 9) r -= 19;
      r = ((r * 11) % 30) + month + day;
      if (month < 3) r += 2;
      let phase = (r + 8) % 30;
      phase = (phase / 30.0) * 360;
      if (phase < 0) phase += 360;
      updateLunarPhaseDisplay(phase);
      return phase;
    }
    function updateLunarPhaseDisplay(degrees) {
      const phases = {
        'Nova': [0, 45],
        'Crescente': [45, 90],
        'Quarto Crescente': [90, 135],
        'Gibosa Crescente': [135, 180],
        'Cheia': [180, 225],
        'Gibosa Minguante': [225, 270],
        'Quarto Minguante': [270, 315],
        'Minguante': [315, 360]
      };
      let phaseName = 'Nova';
      for (const [name, range] of Object.entries(phases)) {
        if (degrees >= range[0] && degrees < range[1]) {
          phaseName = name;
          break;
        }
      }
      const display = document.getElementById('lunar-phase-display');
      if (display) {
        display.innerHTML = `🌙 Fase Lunar: ${phaseName} (${degrees.toFixed(1)}°)`;
      }
    }
    function updateNextCycle() {
      const now = new Date();
      const currentHour = now.getHours();
      const currentMinute = now.getMinutes();
      let nextWindow = null;
      for (const window of ASTRO_TIMES) {
        if (window.h > currentHour || (window.h === currentHour && window.m > currentMinute)) {
          nextWindow = new Date(now);
          nextWindow.setHours(window.h, window.m, 0, 0);
          break;
        }
      }
      if (!nextWindow) {
        nextWindow = new Date(now);
        nextWindow.setDate(nextWindow.getDate() + 1);
        nextWindow.setHours(ASTRO_TIMES[0].h, ASTRO_TIMES[0].m, 0, 0);
      }
      const nextCycle = document.getElementById('next-cycle');
      if (nextCycle) {
        nextCycle.textContent = `Próximo ciclo: ${nextWindow.toLocaleDateString('pt-BR')} às ${nextWindow.toTimeString().slice(0,5)}`;
      }
    }
    function getNextEnergyTime() {
      const now = new Date();
      const next = new Date(now.getTime() + 4 * 60 * 60 * 1000);
      return next.toLocaleString('pt-BR');
    }
    function updateSystemStatus(message) {
      const status = document.getElementById('system-status');
      const statusText = document.getElementById('status-text');
      if (status) status.textContent = message;
      if (statusText) statusText.textContent = message;
    }
    function updateEnergyLevel(level) {
      const energyLevel = document.getElementById('energy-level');
      if (energyLevel) {
        energyLevel.textContent = `Nível energético: ${level}%`;
      }
    }
    function updateEncryptionStatus(message) {
      const encryptionStatus = document.getElementById('encryption-status');
      if (encryptionStatus) {
        encryptionStatus.textContent = `🔐 ${message}`;
      }
    }
    function handleTestimonyUpload(event) {
      const file = event.target.files[0];
      if (file) {
        updateSystemStatus('Foto testemunha carregada');
      }
    }
    function toggleConfig() {
      const form = document.getElementById('config-form');
      if (form) {
        form.style.display = form.style.display === 'none' ? 'block' : 'none';
      }
    }
    function saveConfig() {
      const token = document.getElementById('github-token')?.value;
      const owner = document.getElementById('repo-owner')?.value;
      const repo = document.getElementById('repo-name')?.value;
      if (token && owner && repo) {
        const config = { token, owner, repo };
        try {
          localStorage.setItem('technomagic_config', JSON.stringify(config));
          alert('✅ Configurações salvas! Sistema pronto para operação completa.');
          toggleConfig();
          updateSystemStatus('Sistema configurado - GitHub integrado');
        } catch (error) {
          alert('❌ Erro ao salvar configurações');
        }
      } else {
        alert('⚠️ Preencha todos os campos de configuração');
      }
    }
    function getStoredConfig() {
      try {
        const config = localStorage.getItem('technomagic_config');
        return config ? JSON.parse(config) : { token: '', owner: '', repo: '' };
      } catch (error) {
        return { token: '', owner: '', repo: '' };
      }
    }
    function loadStoredConfig() {
      const config = getStoredConfig();
      if (config.token) {
        const tokenInput = document.getElementById('github-token');
        const ownerInput = document.getElementById('repo-owner');
        const repoInput = document.getElementById('repo-name');
        if (tokenInput) tokenInput.value = config.token;
        if (ownerInput) ownerInput.value = config.owner;
        if (repoInput) repoInput.value = config.repo;
        updateSystemStatus('Configuração carregada do armazenamento');
      }
    }
        // <!-- NOVO: Função para disparar o workflow via GitHub API -->
    async function triggerEnergyWorkflow(quantumCode) {
      const config = getStoredConfig();
      if (!config.token) {
        document.getElementById('workflow-status').classList.remove('hidden');
        document.getElementById('workflow-info').innerHTML = `
          <div>📋 Configure GitHub para ativação automática</div>
          <div>🔄 Workflow manual: Execute energização a cada 4 horas</div>
          <div>⏰ Próxima energização recomendada: ${getNextEnergyTime()}</div>
        `;
        return;
      }
      try {
        const response = await fetch(`https://api.github.com/repos/${config.owner}/${config.repo}/dispatches`, {
          method: 'POST',
          headers: {
            'Authorization': `token ${config.token}`,
            'Accept': 'application/vnd.github.v3+json',
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            event_type: 'energize_manifestation',
            client_payload: {
              quantum_code: quantumCode,
              timestamp: Date.now()
            }
          })
        });
        document.getElementById('workflow-status').classList.remove('hidden');
        if (response.ok) {
          document.getElementById('workflow-info').innerHTML = `
            <div>✅ Workflow de energização ativado</div>
            <div>🤖 Sistema executará automaticamente</div>
            <div>⏰ Próxima execução: ${getNextEnergyTime()}</div>
            <div>🔄 Frequência: A cada 4 horas</div>
            <div style="color: var(--neon-yellow); margin-top: 10px;">
              ✨ Ancoragem temporal e reforço de campo morfogenético em operação.
            </div>
          `;
        } else {
          const errorText = await response.text();
          throw new Error(`Dispatch failed: ${response.status} - ${errorText}`);
        }
      } catch (error) {
        console.error('Erro ao ativar workflow:', error);
        document.getElementById('workflow-info').innerHTML = `
          <div>⚠️ Erro ao ativar workflow: ${error.message}</div>
          <div>📋 Verifique seu token e permissões no GitHub</div>
        `;
      }
    }
    // <!-- FIM NOVO -->
    // <!-- NOVO: Função para gerar chave de criptografia -->
    function generateEncryptionKey() {
      const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
      let result = '';
      for (let i = 0; i < 32; i++) {
        result += chars.charAt(Math.floor(Math.random() * chars.length));
      }
      return result;
    }
    // <!-- FIM NOVO -->
    function startQuantumAnimation() {
      const background = document.querySelector('.quantum-background');
      if (!background) return;
      let rotation = 0;
      function animate() {
        rotation += 0.2;
        background.style.transform = `rotate(${rotation}deg) scale(${1 + Math.sin(rotation * 0.01) * 0.1})`;
        requestAnimationFrame(animate);
      }
      animate();
    }
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }
    function debounce(func, wait) {
      let timeout;
      return function executedFunction(...args) {
        const later = () => {
          clearTimeout(timeout);
          func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    }
    setInterval(() => {
      updateNextCycle();
      calculateLunarPhase();
    }, 60000);
    const formElements = ['intent', 'name', 'birthDate', 'location'];
    formElements.forEach(elementId => {
      const element = document.getElementById(elementId);
      if (element) {
        const savedValue = localStorage.getItem(`form_${elementId}`);
        if (savedValue) {
          element.value = savedValue;
        }
        element.addEventListener('input', () => {
          localStorage.setItem(`form_${elementId}`, element.value);
        });
      }
    });
  </script>
</body>
</html>